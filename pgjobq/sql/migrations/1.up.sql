CREATE SCHEMA pgjobq;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

create table pgjobq.migrations (
    current_revision smallint not null
);

INSERT INTO pgjobq.migrations VALUES (0);

create table pgjobq.queues (
    id serial primary key,
    name text not null,
    UNIQUE(name),
    ack_deadline interval not null,
    max_delivery_attempts integer not null,
    retention_period interval not null
);

create table pgjobq.messages (
    queue_id serial references pgjobq.queues on delete cascade not null,
    id uuid, -- generated by app so it can start waiting for results before publishing
    PRIMARY KEY(queue_id, id),
    expires_at timestamp not null,
    delivery_attempts_remaining integer not null,
    available_at timestamp not null,
    body bytea not null
) PARTITION BY LIST(queue_id);

-- Indexes for looking for expired messages
CREATE INDEX expiration_idx
ON pgjobq.messages
USING BRIN(expires_at);

CREATE INDEX delivery_attempt_idx
ON pgjobq.messages(delivery_attempts_remaining)
WHERE delivery_attempts_remaining = 0;

CREATE INDEX available_at_idx
ON pgjobq.messages
USING BRIN(available_at);

CREATE FUNCTION pgjobq.create_queue(
    queue_name varchar(32),
    ack_deadline interval,
    max_delivery_attempts integer,
    retention_period interval
)
    RETURNS boolean
    LANGUAGE plpgsql AS
$$
DECLARE
    found_queue_id integer;
    messages_partition_table_name text;
BEGIN
    messages_partition_table_name := 'pgjobq.messages_' || queue_name;
    WITH new_queue AS (
        INSERT INTO pgjobq.queues(name, ack_deadline, max_delivery_attempts, retention_period)
        VALUES (queue_name, ack_deadline, max_delivery_attempts, retention_period)
        ON CONFLICT DO NOTHING
        RETURNING id AS queue_id
    )
    SELECT queue_id
    INTO found_queue_id
    FROM new_queue;
    IF found THEN
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS %I PARTITION OF pgjobq.messages FOR VALUES IN (%L);',
            messages_partition_table_name,
            found_queue_id
        );
    END IF;
    RETURN found;
END
$$;

CREATE FUNCTION pgjobq.delete_queue(queue_name varchar(32))
  RETURNS boolean
  LANGUAGE sql AS
$$
    DELETE FROM pgjobq.queues WHERE name = queue_name
    RETURNING 'true'::boolean;
$$;

CREATE FUNCTION pgjobq.publish_message(
    text, -- queue name
    uuid, -- id
    bytea, -- body
    delay interval
)
    RETURNS int
    LANGUAGE 'sql' AS
$$
    WITH queue_info AS (
        SELECT
            id AS queue_id,
            retention_period,
            max_delivery_attempts
        FROM pgjobq.queues
        WHERE name = $1
    ), published_notification AS (
        -- empty notification body for now
        -- but make it valid JSON so we can put stuff in there if we want
        SELECT
            pg_notify((SELECT 'new_message_' || $1), '{}')
    )
    INSERT INTO pgjobq.messages(
        queue_id,
        id,
        expires_at,
        delivery_attempts_remaining,
        available_at,
        body
    )
    SELECT
        queue_id,
        $2,
        now() + retention_period,
        max_delivery_attempts,
        -- set next ack to now
        -- somewhat meaningless but avoids nulls
        now() + delay,
        $3
    FROM queue_info
    LEFT JOIN published_notification ON 1 = 1
    RETURNING 1;  -- NULL if the queue doesn't exist
$$;

CREATE FUNCTION pgjobq.cleanup_dead_messages()
    RETURNS VOID
    LANGUAGE sql AS
$$
    DELETE
    FROM pgjobq.messages
    WHERE (
        available_at < now()
        AND (
            expires_at < now()
            OR
            delivery_attempts_remaining = 0
        )
    );
$$;

CREATE FUNCTION pgjobq.poll_for_messages(
    text, -- queue name
    smallint -- batch_size
)
    RETURNS table(id uuid, next_ack_deadline timestamp, body bytea)
    LANGUAGE sql AS
$$
    WITH queue_info AS (
        SELECT
            id,
            ack_deadline
        FROM pgjobq.queues
        WHERE name = $1
    ), selected_messages AS (
        SELECT
            id
        FROM pgjobq.messages
        WHERE (
            delivery_attempts_remaining != 0
            AND
            expires_at > now()
            AND
            available_at < now()
            AND
            queue_id = (SELECT id FROM queue_info)
        )
        FOR UPDATE SKIP LOCKED
        LIMIT $2
    )
    UPDATE pgjobq.messages
    SET
        available_at = now() + (SELECT ack_deadline FROM queue_info),
        delivery_attempts_remaining = delivery_attempts_remaining - 1
    FROM selected_messages
    WHERE pgjobq.messages.id = selected_messages.id
    RETURNING pgjobq.messages.id, available_at AS next_ack_deadline, body
END
$$;

CREATE FUNCTION pgjobq.ack_message(
    text, -- queue name
    uuid -- id
)
    RETURNS VOID
    LANGUAGE sql AS
$$
    SELECT * FROM pg_notify('done_' || $1::text || '_' || $2::text, '{}');
    DELETE FROM pgjobq.messages
    WHERE queue_id = (SELECT id FROM pgjobq.queues WHERE name = $1) AND id = $2;
$$;

CREATE FUNCTION pgjobq.extend_ack_deadline(
    text, -- queue name
    uuid -- id
)
    RETURNS timestamp
    LANGUAGE sql AS
$$
    WITH message_for_update AS (
        SELECT
            id,
            queue_id
        FROM pgjobq.messages
        WHERE queue_id = (SELECT id FROM pgjobq.queues WHERE name = $1) AND id = $2
        FOR UPDATE SKIP LOCKED
    )
    UPDATE pgjobq.messages
    SET available_at = (
        now() + (
            SELECT ack_deadline
            FROM pgjobq.queues
            WHERE pgjobq.queues.id = (
                SELECT queue_id FROM message_for_update
            )
        )
    )
    WHERE pgjobq.messages.id = (
        SELECT id FROM message_for_update
    )
    RETURNING available_at AS next_ack_deadline;
$$;

CREATE FUNCTION pgjobq.nack_message(
    text, -- queue name
    uuid -- id
)
    RETURNS VOID
    LANGUAGE sql AS
$$
    UPDATE pgjobq.messages
    SET available_at = now()
    WHERE queue_id = (SELECT id FROM pgjobq.queues WHERE name = $1) AND id = $2;
$$;

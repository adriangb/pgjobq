CREATE SCHEMA pgmq;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

create table pgmq.migrations (
    current_revision smallint not null
);

INSERT INTO pgmq.migrations VALUES (0);

create table pgmq.queues (
    id serial primary key,
    name text not null,
    UNIQUE(name),
    ack_deadline interval not null,
    max_delivery_attempts integer not null,
    retention_period interval not null
);

create table pgmq.messages (
    queue_id serial references pgmq.queues on delete cascade not null,
    id uuid, -- generated by app so it can start waiting for results before publishing
    PRIMARY KEY(queue_id, id),
    expires_at timestamp not null,
    delivery_attempts_remaining integer not null,
    available_at timestamp not null,
    body bytea not null,
    attributes jsonb
) PARTITION BY LIST(queue_id);

create table pgmq.queue_link_types(
    id serial primary key,
    name text not null,
    UNIQUE(name)
);

-- TODO: fan-out, reply-to?
INSERT INTO pgmq.queue_link_types(name)
VALUES ('dlq');

create table pgmq.queue_links(
    id serial primary key,
    parent_id serial references pgmq.queues on delete cascade not null,
    link_type_id serial references pgmq.queue_link_types on delete cascade not null,
    child_id serial references pgmq.queues on delete cascade not null,
    UNIQUE(parent_id, link_type_id, child_id)
);

-- Index for ackinc/nacknig messages within a partition
CREATE INDEX "pgmq.messages_id_idx" ON pgmq.messages(id);

-- Indexes for looking for expired messages and available messages
CREATE INDEX "pgmq.messages_available_idx"
ON pgmq.messages(available_at);

CREATE INDEX "pgmq.messages_expiration_idx"
ON pgmq.messages(delivery_attempts_remaining, expires_at);

-- Triggers for managing partitions
CREATE OR REPLACE FUNCTION pgmq.create_message_partitions() RETURNS trigger AS
$$
DECLARE
    messages_partition_table_name text;
BEGIN
    messages_partition_table_name :=  'messages_' || NEW.id::text;
    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS pgmq.%I PARTITION OF pgmq.messages FOR VALUES IN (%L);',
        messages_partition_table_name,
        NEW.id
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER "pgmq.create_message_partitions"
AFTER INSERT ON pgmq.queues FOR EACH ROW
EXECUTE PROCEDURE pgmq.create_message_partitions();

CREATE OR REPLACE FUNCTION pgmq.drop_messages_partitions() RETURNS trigger AS
$$
DECLARE
    messages_partition_table_name text;
BEGIN
    messages_partition_table_name :=  'messages_' || OLD.id::text;
    EXECUTE format(
        'DROP TABLE IF EXISTS pgmq.%I CASCADE;',
        messages_partition_table_name
    );
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
